---------------------------------------------------------------------------------------------
--
--	Université de Sherbrooke
--  Département de génie électrique et génie informatique
--
--	S4i - APP4
--
--
--	Auteur: 		Marc-André Tétrault
--					Daniel Dalle
--					Sébastien Roy
--
---------------------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all; -- requis pour la fonction "to_integer"
use work.MIPS32_package.all;

entity MemInstructions is
Port (
    i_addresse 		: in std_logic_vector (31 downto 0);
    o_instruction 	: out std_logic_vector (31 downto 0)
);
end MemInstructions;

architecture Behavioral of MemInstructions is
    signal ram_Instructions : RAM(0 to 255) := (
------------------------
-- Insérez votre code ici
------------------------

-- test_vanilla_load:
-- "001111"
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "100011": load 0xdead into $t4
"10001100001011000000000000000000", -- lw  $12 0x00000000($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- test_vanilla_store:
-- "001111"
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "101011" store 0xdead from $t4 into out_norm .data
"10101100001011000000000000001000", -- sw  $12 00x00000008($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- test_vanilla_add:
-- "001111"
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "100011" load 0xbeef into $t5
"10001100001011010000000000000100", -- lw $13 0x00000004($1)
-- "011100" add $t4 (0xdead) with $t5 (0xbeef), resulting in 0x19d9c
"00000001100011010111000000100000", -- add $14 $12 $13
-- "001111"
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "101011" store that sum into  sum_norm .data
"10101100001011100000000000001100", -- sw  $14 0x0000000c($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- test_vec_load:
-- "001111"
"00111100000000010001000000000001", -- lui $1 0x00001001
-- "011110" load [b,e,n,c] into $z0 from ben_vec .data
"01111000001010000000000000010000", -- lwv  $8 0x00000010($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- test_vec_store:
-- "001111"
"00111100000000010001000000000001", -- lui $1 0x00001001
-- "011111" store [B,E,N,C] from $z0 into out_vec .data
"01111100001010000000000000110000", -- swv  $8 0x00000030($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- test_vec_add:
-- "001111"
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "011110" load [32,32,32,32] into $z1 from lower_vec .data
"01111000001010010000000000100000", -- lwv  $9  0x00000020($1)
-- "011100" add $z0 (BENC) and $z1 (lower) into $z2 (equals benc)
"01110001000010010101000000100001", -- addv $10 $8 $9
-- "001111" store $z2 (benc) into out_vec .data
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "011111"
"01111100001010100000000000110000", -- swv  $10 0x00000030($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- test_vec_min:
-- "011101"
"01110101000010110000000000101010", -- minv $11 $8 0x0000002a
-- "001111"
"00111100000000010001000000000001", -- lui $1  0x00001001
-- "011111"
"01111100001010110000000001000000", -- swv  $11 0x00000040($1)
-- "000000"
"00000000000000000000000000000000", -- nop x1
-- "000000"
"00000000000000000000000000000000", -- nop x2
-- "000000"
"00000000000000000000000000000000", -- nop x3
-- "000000"
"00000000000000000000000000000000", -- nop x4
-- "000000"
"00000000000000000000000000000000", -- nop x5

-- end:
-- "001001"
"00100100000000100000000000001010", -- addiu $2 $0 0x0000000a
-- "000000"
"00000000000000000000000000001100", -- syscall

-- --  TestMirroir
-- X"20100024",
-- X"3c011001",
-- X"00300821",
-- X"8c240000",
-- X"0004c820",
-- X"0c100007",
-- X"08100015",
-- X"00805020",
-- X"00001020",
-- X"200cffff",
-- X"340b8000",
-- X"000b5c00",
-- X"20090020",
-- X"11200006",
-- X"00021042",
-- X"014b4024",
-- X"00481025",
-- X"000a5040",
-- X"2129ffff",
-- X"0810000d",
-- X"03e00008",
-- X"00402820",
-- X"22100004",
-- X"3c011001",
-- X"00300821",
-- X"ac220000",
-- X"2002000a",
-- X"0000000c",


------------------------
-- Fin de votre code
------------------------
    others => X"00000000"); --> SLL $zero, $zero, 0

    signal s_MemoryIndex : integer range 0 to 255;

begin
    -- Conserver seulement l'indexage des mots de 32-bit/4 octets
    s_MemoryIndex <= to_integer(unsigned(i_addresse(9 downto 2)));

    -- Si PC vaut moins de 127, présenter l'instruction en mémoire
    o_instruction <= ram_Instructions(s_MemoryIndex) when i_addresse(31 downto 10) = (X"00400" & "00")
                    -- Sinon, retourner l'instruction nop X"00000000": --> AND $zero, $zero, $zero
                    else (others => '0');

end Behavioral;

