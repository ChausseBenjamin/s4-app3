---------------------------------------------------------------------------------------------
--
--	Université de Sherbrooke
--  Département de génie électrique et génie informatique
--
--	S4i - APP4
--
--
--	Auteur: 		Marc-André Tétrault
--					Daniel Dalle
--					Sébastien Roy
--
---------------------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all; -- requis pour la fonction "to_integer"
use work.MIPS32_package.all;

entity MemInstructions is
Port (
    i_addresse 		: in std_logic_vector (31 downto 0);
    o_instruction 	: out std_logic_vector (31 downto 0)
);
end MemInstructions;

architecture Behavioral of MemInstructions is
    signal ram_Instructions : RAM(0 to 255) := (
------------------------
-- Insérez votre code ici
------------------------

-- test_vanilla_load: WORKED
-- "001111"
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "100011": load 0xdead into $t4
--"10001100001011000000000000000000", -- lw  $12 0x00000000($1)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- test_vanilla_store: WORKED. Seen in the RAM.
---- "001111"
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "101011" store 0xdead from $t4 into out_norm .data
--"10101100001011000000000000001000", -- sw  $12 00x00000008($1)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- test_vanilla_add: WORKED.
---- "001111"
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "100011" load 0xbeef into $t5
--"10001100001011010000000000000100", -- lw $13 0x00000004($1)
---- "011100" add $t4 (0xdead) with $t5 (0xbeef), resulting in 0x19d9c
--"00000001100011010111000000100000", -- add $14 $12 $13
---- "001111"
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "101011" store that sum into  sum_norm .data
--"10101100001011100000000000001100", -- sw  $14 0x0000000c($1)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- test_vec_load: WORKED. Data put in registers properly
---- "001111"
--"00111100000000010001000000000001", -- lui $1 0x00001001
---- "011110" load [b,e,n,c] into $z0 from ben_vec .data
--"01111000001000000000000000010000", -- lwv  $8 0x00000010($1) (loaded into 00000)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- test_vec_store: Put in RAM successfully.
---- "001111"
--"00111100000000010001000000000001", -- lui $1 0x00001001
---- "011111" store [B,E,N,C] from $z0 into out_vec .data
--"01111100001000000000000000110000", -- swv  $8 0x00000030($1) (stores data from 00000)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- test_vec_add:
---- "001111"
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "011110" load [32,32,32,32] into $z1 from lower_vec .data
--"01111000001000010000000000100000", -- lwv  $9  0x00000020($1)      WORKED (put data at 00001)
---- "011100" add $z0 (BENC) and $z1 (lower) into $z2 (equals benc)   WORKED
--"01110000000000010001000000100001", -- addv $10 $8 $9           Puts data at 00010 from add 00001 + 00000
---- "001111" store $z2 (benc) into out_vec .data
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "011111"
--"01111100001010100000000000110000", -- swv  $10 0x00000030($1)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- test_vec_min:
---- "011101"
--"01110100000011110000000000101010", -- minv $11 $8 0x0000002a (minimum of 00000 into 01111 ($t7) - WORKED!
---- "001111"
--"00111100000000010001000000000001", -- lui $1  0x00001001
---- "011111"
--"10101100001011110000000001000000", -- swv  $11 0x00000040($1)
---- "000000"
--"00000000000000000000000000000000", -- nop x1
---- "000000"
--"00000000000000000000000000000000", -- nop x2
---- "000000"
--"00000000000000000000000000000000", -- nop x3
---- "000000"
--"00000000000000000000000000000000", -- nop x4
---- "000000"
--"00000000000000000000000000000000", -- nop x5

---- end:
---- "001001"
--"00100100000000100000000000001010", -- addiu $2 $0 0x0000000a
---- "000000"
--"00000000000000000000000000001100", -- syscall

------------------------------------------------------------------
-- Vitberbis
------------------------------------------------------------------
--"00111100000000010001000000000001",
--"00110100001001000000000000010000",
--"00111100000000010001000000000001",
--"00110100001001010000000000100000",
--"00111100000000010001000000000001",
--"00110100001001100000000001100000",
--"00001100000100000000000000001001",
--"00100100000000100000000000001010",
--"00000000000000000000000000001100",
--"00100011101111011111111111100000",
--"10101111101111110000000000000000",
--"10101111101001000000000000000100",
--"10101111101001010000000000001000",
--"10101111101001100000000000001100",
--"10001111101010000000000000001100",
--"00000000000000000000000000000000",

--"00111100000000010001000000000001", -- lui
--"01111000001000000000000000000000", -- lwv $z0, 0() 
--"01111101000000000000000000000000", -- swv $z0 12($sp)

--"00000000000000000000000000000000",
--"00100100000010000000000000000000",
--"10101111101010000000000000010000",
--"10001111101010000000000000010000",
--"00100000000000010000000001000000",
--"00010000001010000000000000001101",
--"10001111101001000000000000000100",
--"10001111101011010000000000001000",
--"00000001101010000110000000100000",
--"00000000000011000010100000100001",
--"00100001000010100000000000000000",
--"00000000000010100100100010000010",
--"10001111101011010000000000001100",
--"00000001101010010110000000100000",
--"10001101100001100000000000000000",
--"00100001000010000000000000010000",
--"10101111101010000000000000010000",
--"00001100000100000000000000101001",
--"00001000000100000000000000010110",
--"10001111101111110000000000000000",
--"00100011101111010000000000100000",
--"00000011111000000000000000001000",
--"00000000000010000011000000100001",
--"00000000000000000000000000000000",

--"01111000100000010000000000000000", -- lwv $z0, 0($a0) - 00001
--"01111000101000100000000000000000", -- lwv $z1, 0($a1) - 00010
--"01110000010000010001100000100001", -- addv $z2, $z1, $z0 - 00011
--"01110100011010010000000000000000", -- minv $t1, $z2

--"00000000000000000000000000000000",
--"00000001000010010000100000101010",
--"00010100001000000000000000000001",
--"10101101000010010000000000000000",
--"00000011111000000000000000001000",

"00111100000000010001000000000001",
"00110100001001000000000000010000",
"00111100000000010001000000000001",
"00110100001001010000000000100000",
"00111100000000010001000000000001",
"00110100001001100000000001100000",
"00001100000100000000000000001001",
"00100100000000100000000000001010",
"00000000000000000000000000001100",
"00100011101111011111111111100000",
"10101111101111110000000000000000",
"10101111101001000000000000000100",
"10101111101001010000000000001000",
"10101111101001100000000000001100",
"10001111101010000000000000001100",
"00000000000000000000000000000000",

"00111100000000010001000000000001", -- lui
"01111000001000000000000000000000", -- lwv $z0, 0() 
"01111101000000000000000000000000", -- swv $z0 12($sp)

"00000000000000000000000000000000",
"00100100000010000000000000000000",
"10101111101010000000000000010000",
"10001111101010000000000000010000",
"00100000000000010000000001000000",
"00010000001010000000000000001101",
"10001111101001000000000000000100",
"10001111101011010000000000001000",
"00000001101010000110000000100000",
"00000000000011000010100000100001",
"00100001000010100000000000000000",
"00000000000010100100100010000010",
"10001111101011010000000000001100",
"00000001101010010110000000100000",
"00000000000011000011000000100001",
"00100001000010000000000000010000",
"10101111101010000000000000010000",
"00001100000100000000000000101001",
"00001000000100000000000000010110",
"10001111101111110000000000000000",
"00100011101111010000000000100000",
"00000011111000000000000000001000",
"00000000000000000000000000000000",

"01111000100000010000000000000000", -- lwv $z0, 0($a0) - 00001
"01111000101000100000000000000000", -- lwv $z1, 0($a1) - 00010
"01110000010000010001100000100001", -- addv $z2, $z1, $z0 - 00011
"01110100011010010000000000000000", -- minv $t1, $z2

"00000000000000000000000000000000",
"10001100110010000000000000000000",
"00000001000010010000100000101010",
"00010100001000000000000000000001",
"10101100110010010000000000000000",
"00000011111000000000000000001000",


-- --  TestMirroir
-- X"20100024",
-- X"3c011001",
-- X"00300821",
-- X"8c240000",
-- X"0004c820",
-- X"0c100007",
-- X"08100015",
-- X"00805020",
-- X"00001020",
-- X"200cffff",
-- X"340b8000",
-- X"000b5c00",
-- X"20090020",
-- X"11200006",
-- X"00021042",
-- X"014b4024",
-- X"00481025",
-- X"000a5040",
-- X"2129ffff",
-- X"0810000d",
-- X"03e00008",
-- X"00402820",
-- X"22100004",
-- X"3c011001",
-- X"00300821",
-- X"ac220000",
-- X"2002000a",
-- X"0000000c",


------------------------
-- Fin de votre code
------------------------
    others => X"00000000"); --> SLL $zero, $zero, 0

    signal s_MemoryIndex : integer range 0 to 255;

begin
    -- Conserver seulement l'indexage des mots de 32-bit/4 octets
    s_MemoryIndex <= to_integer(unsigned(i_addresse(9 downto 2)));

    -- Si PC vaut moins de 127, présenter l'instruction en mémoire
    o_instruction <= ram_Instructions(s_MemoryIndex) when i_addresse(31 downto 10) = (X"00400" & "00")
                    -- Sinon, retourner l'instruction nop X"00000000": --> AND $zero, $zero, $zero
                    else (others => '0');

end Behavioral;

